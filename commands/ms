#!/usr/bin/env bash
# ==============================================================================
# MIDI Studio CLI
# Cross-platform build tool for midi-studio project
# ==============================================================================

set -euo pipefail

# ==============================================================================
# Configuration
# ==============================================================================

readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly WORKSPACE="$(cd "$SCRIPT_DIR/.." && pwd)"
readonly ROOT="$WORKSPACE/midi-studio"
readonly OC_TOOLS="$WORKSPACE/open-control/cli-tools/bin"
readonly OC_BRIDGE="$WORKSPACE/open-control/bridge/target/release/oc-bridge"
readonly EMSDK_DIR="$WORKSPACE/tools/emsdk"
readonly TOOLS_DIR="$WORKSPACE/tools"

# Bridge process management
BRIDGE_PID=""

cleanup_bridge() {
    if [[ -n "$BRIDGE_PID" ]] && kill -0 "$BRIDGE_PID" 2>/dev/null; then
        kill "$BRIDGE_PID" 2>/dev/null
        wait "$BRIDGE_PID" 2>/dev/null || true
    fi
}

start_bridge() {
    local transport="$1"
    local port="$2"
    
    if [[ ! -x "$OC_BRIDGE" ]]; then
        log_error "Bridge not found: $OC_BRIDGE"
        log_error "Run: cd open-control/bridge && cargo build --release"
        return 1
    fi
    
    trap cleanup_bridge EXIT INT TERM
    
    "$OC_BRIDGE" --headless --controller "$transport" --controller-port "$port" &
    BRIDGE_PID=$!
    sleep 0.3
    
    if ! kill -0 "$BRIDGE_PID" 2>/dev/null; then
        log_error "Bridge failed to start"
        return 1
    fi
}

# Extract port from C++ source
get_ws_port() {
    local main_file="$1"
    grep -oP 'localhost:\K[0-9]+' "$main_file" 2>/dev/null | head -1 || true
}

get_udp_port() {
    local main_file="$1"
    grep -oP '\.port = \K[0-9]+' "$main_file" 2>/dev/null | head -1 || true
}

# PID of background bridge process
BRIDGE_PID=""

# ==============================================================================
# Platform Detection
# ==============================================================================

detect_platform() {
    case "$(uname -s)" in
        CYGWIN*|MINGW*|MSYS*) echo "windows" ;;
        Darwin*)              echo "macos" ;;
        Linux*)               echo "linux" ;;
        *)                    echo "unknown" ;;
    esac
}

readonly PLATFORM="$(detect_platform)"

# ==============================================================================
# Terminal Output
# ==============================================================================

setup_colors() {
    if [[ -t 1 ]] && [[ -z "${NO_COLOR:-}" ]] && [[ "${TERM:-dumb}" != "dumb" ]]; then
        RED=$'\033[31m'
        GREEN=$'\033[32m'
        CYAN=$'\033[36m'
        BOLD=$'\033[1m'
        DIM=$'\033[2m'
        RESET=$'\033[0m'
    else
        RED='' GREEN='' CYAN='' BOLD='' DIM='' RESET=''
    fi
}

setup_colors

log_info()  { printf '%s\n' "${CYAN}>${RESET} $*"; }
log_ok()    { printf '%s\n' "${GREEN}>${RESET} $*"; }
log_error() { printf '%s\n' "${RED}error:${RESET} $*" >&2; }
log_die()   { log_error "$@"; exit 1; }

# ==============================================================================
# Emscripten Setup
#
# Uses Python to call emscripten tools directly - works on all platforms
# without relying on .bat/.cmd resolution in PATH
# ==============================================================================

emscripten_init() {
    [[ -n "${EMSCRIPTEN_INITIALIZED:-}" ]] && return 0
    
    local em_dir="$EMSDK_DIR/upstream/emscripten"
    
    if [[ ! -d "$em_dir" ]]; then
        log_die "Emscripten not installed. Run: ms setup"
    fi
    
    # Source emsdk environment
    if [[ -f "$EMSDK_DIR/emsdk_env.sh" ]]; then
        # shellcheck source=/dev/null
        source "$EMSDK_DIR/emsdk_env.sh" > /dev/null 2>&1 || true
    fi
    
    # Verify python is available
    if ! command -v python &>/dev/null && ! command -v python3 &>/dev/null; then
        log_die "Python is required for Emscripten"
    fi
    
    # Set python command
    if command -v python3 &>/dev/null; then
        PYTHON_CMD="python3"
    else
        PYTHON_CMD="python"
    fi
    
    # Store emscripten directory for tool calls
    EMSCRIPTEN_DIR="$em_dir"
    EMSCRIPTEN_INITIALIZED=1
    
    export EMSCRIPTEN_DIR EMSCRIPTEN_INITIALIZED PYTHON_CMD
}

# Wrapper to call emscripten tools via Python (portable)
emtool() {
    local tool="$1"
    shift
    emscripten_init
    "$PYTHON_CMD" "$EMSCRIPTEN_DIR/${tool}.py" "$@"
}

# ==============================================================================
# Codebase Resolution
# ==============================================================================

resolve_codebase() {
    local name="${1:-}"
    
    [[ -z "$name" ]] && log_die "Codebase required (core, bitwig, ...)"
    
    if [[ "$name" == "core" ]]; then
        echo "$ROOT/core"
    elif [[ -d "$ROOT/plugin-$name" ]]; then
        echo "$ROOT/plugin-$name"
    else
        log_die "Unknown codebase: $name (use 'ms list' to see available)"
    fi
}

list_codebases() {
    local codebases=("core")
    for dir in "$ROOT"/plugin-*/; do
        [[ -d "$dir" ]] && codebases+=("$(basename "$dir" | sed 's/plugin-//')")
    done
    printf '%s\n' "${codebases[@]}"
}

# ==============================================================================
# Build Commands - Teensy
# ==============================================================================

cmd_teensy_build() {
    local codebase="$1"
    local env="${2:-dev}"
    local codebase_path
    codebase_path="$(resolve_codebase "$codebase")"
    
    log_info "Building $codebase (teensy $env)"
    cd "$codebase_path"
    "$OC_TOOLS/oc-build" "$env"
}

cmd_teensy_upload() {
    local codebase="$1"
    local env="${2:-dev}"
    local codebase_path
    codebase_path="$(resolve_codebase "$codebase")"
    
    log_info "Uploading $codebase (teensy $env)"
    cd "$codebase_path"
    "$OC_TOOLS/oc-upload" "$env"
}

cmd_teensy_monitor() {
    local codebase="$1"
    local env="${2:-dev}"
    local codebase_path
    codebase_path="$(resolve_codebase "$codebase")"
    
    log_info "Monitoring $codebase (teensy $env)"
    cd "$codebase_path"
    "$OC_TOOLS/oc-monitor" "$env"
}

# ==============================================================================
# Dependency Management
#
# Cross-platform dependency checking with clear user feedback.
# - Linux: uses pkg-config, shows distro-specific install commands
# - Windows: checks for bundled tools in tools/windows/
# - macOS: uses pkg-config (assumes Homebrew)
# ==============================================================================

# Detect Linux distribution family
# Returns: fedora, debian, arch, or unknown
detect_distro() {
    [[ ! -f /etc/os-release ]] && { echo "unknown"; return; }
    
    . /etc/os-release
    case "$ID" in
        fedora|rhel|centos|rocky|alma) echo "fedora" ;;
        ubuntu|debian|pop|mint|elementary|linuxmint) echo "debian" ;;
        arch|manjaro|endeavouros|garuda) echo "arch" ;;
        opensuse*|suse) echo "suse" ;;
        *) echo "unknown" ;;
    esac
}

# Get the package install command for current platform/distro
# Returns: install command prefix (e.g., "sudo dnf install")
get_install_cmd() {
    case "$PLATFORM" in
        linux)
            case "$(detect_distro)" in
                fedora) echo "sudo dnf install" ;;
                debian) echo "sudo apt install" ;;
                arch)   echo "sudo pacman -S" ;;
                suse)   echo "sudo zypper install" ;;
                *)      echo "# Install via your package manager:" ;;
            esac
            ;;
        macos)  echo "brew install" ;;
        *)      echo "# Install:" ;;
    esac
}

# Check dependencies and display missing ones with install instructions
#
# Usage: check_deps dep1 dep2 ...
#
# Dependency format (colon-separated):
#   check_method:name:fedora:debian:arch:macos:required:description
#
# Check methods:
#   pkg=NAME     - pkg-config --exists NAME
#   cmd=NAME     - command -v NAME
#   file=PATH    - test -e PATH (relative to WORKSPACE)
#
# Example:
#   check_deps \
#       "pkg=sdl2:SDL2:SDL2-devel:libsdl2-dev:sdl2:sdl2:required:Graphics" \
#       "cmd=ninja:Ninja:ninja-build:ninja-build:ninja:ninja:required:Build tool"
#
check_deps() {
    local missing_required=()
    local missing_optional=()
    local distro install_cmd
    
    distro="$(detect_distro)"
    install_cmd="$(get_install_cmd)"
    
    for dep in "$@"; do
        IFS=':' read -r check name fedora debian arch macos required desc <<< "$dep"
        
        # Determine check method and perform check
        local found=false
        case "$check" in
            pkg=*)
                local pkg="${check#pkg=}"
                pkg-config --exists "$pkg" 2>/dev/null && found=true
                ;;
            cmd=*)
                local cmd="${check#cmd=}"
                command -v "$cmd" &>/dev/null && found=true
                ;;
            file=*)
                local file="${check#file=}"
                [[ -e "$WORKSPACE/$file" ]] && found=true
                ;;
        esac
        
        if [[ "$found" == false ]]; then
            # Select package name for current platform (- means use default name)
            local pkg_name="$name"
            case "$PLATFORM" in
                linux)
                    case "$distro" in
                        fedora) [[ "$fedora" != "-" ]] && pkg_name="$fedora" ;;
                        debian) [[ "$debian" != "-" ]] && pkg_name="$debian" ;;
                        arch)   [[ "$arch" != "-" ]] && pkg_name="$arch" ;;
                        *)      [[ "$fedora" != "-" ]] && pkg_name="$fedora" ;;
                    esac
                    ;;
                macos) [[ "$macos" != "-" ]] && pkg_name="$macos" ;;
            esac
            
            if [[ "$required" == "required" ]]; then
                missing_required+=("$pkg_name|$desc")
            else
                missing_optional+=("$pkg_name|$desc")
            fi
        fi
    done
    
    # Nothing missing
    [[ ${#missing_required[@]} -eq 0 && ${#missing_optional[@]} -eq 0 ]] && return 0
    
    # Display missing required dependencies
    if [[ ${#missing_required[@]} -gt 0 ]]; then
        log_error "Missing required dependencies:"
        echo ""
        for item in "${missing_required[@]}"; do
            IFS='|' read -r pkg desc <<< "$item"
            printf "  ${RED}*${RESET} %-24s %s\n" "$pkg" "($desc)"
        done
        echo ""
    fi
    
    # Display missing optional dependencies
    if [[ ${#missing_optional[@]} -gt 0 ]]; then
        log_info "Missing optional dependencies:"
        echo ""
        for item in "${missing_optional[@]}"; do
            IFS='|' read -r pkg desc <<< "$item"
            printf "  ${DIM}*${RESET} %-24s %s\n" "$pkg" "($desc)"
        done
        echo ""
    fi
    
    # Build and display install command
    local all_pkgs=()
    for item in "${missing_required[@]}" "${missing_optional[@]}"; do
        IFS='|' read -r pkg _ <<< "$item"
        [[ -n "$pkg" ]] && all_pkgs+=("$pkg")
    done
    
    if [[ ${#all_pkgs[@]} -gt 0 ]]; then
        echo "Install with:"
        echo "  $install_cmd ${all_pkgs[*]}"
        echo ""
    fi
    
    # Fail only if required deps are missing
    [[ ${#missing_required[@]} -gt 0 ]] && return 1
    return 0
}

# Check native build dependencies for current platform
check_native_deps() {
    local missing=()

    # Build tools
    command -v cmake &>/dev/null || missing+=("cmake")
    command -v ninja &>/dev/null || missing+=("ninja")

    # C++ compiler
    if [[ "$PLATFORM" == "macos" ]]; then
        command -v clang++ &>/dev/null || missing+=("clang++ (xcode-select --install)")
    else
        command -v g++ &>/dev/null || missing+=("g++")
    fi

    # SDL2
    if [[ "$PLATFORM" == "windows" ]]; then
        [[ -d "$TOOLS_DIR/windows/SDL2" ]] || missing+=("SDL2 (bundled)")
    else
        pkg-config --exists sdl2 2>/dev/null || missing+=("SDL2")
    fi

    # Report missing
    if [[ ${#missing[@]} -gt 0 ]]; then
        log_error "Missing: ${missing[*]}"
        echo ""
        case "$PLATFORM" in
            linux)
                case "$(detect_distro)" in
                    fedora) echo "  sudo dnf install cmake ninja-build gcc-c++ SDL2-devel" ;;
                    debian) echo "  sudo apt install cmake ninja-build g++ libsdl2-dev" ;;
                    arch)   echo "  sudo pacman -S cmake ninja gcc sdl2" ;;
                    *)      echo "  Install: cmake, ninja, g++, SDL2-devel" ;;
                esac
                ;;
            macos)  echo "  brew install cmake ninja sdl2" ;;
        esac
        echo ""
        return 1
    fi
}

# ==============================================================================
# Build Commands - Native (SDL Desktop)
# ==============================================================================

cmd_native_build() {
    local codebase="$1"
    local codebase_path build_dir app_path
    codebase_path="$(resolve_codebase "$codebase")"
    build_dir="$ROOT/.build/$codebase/native"
    app_path="$codebase_path/sdl"
    
    log_info "Building $codebase (native)"
    
    check_native_deps || return 1
    
    if [[ ! -f "$build_dir/build.ninja" ]]; then
        local cmake_args=(
            -G Ninja
            -S "$ROOT/core/sdl"
            -B "$build_dir"
            -DAPP_PATH="$app_path"
            -DBIN_OUTPUT_DIR="$ROOT/bin"
            -DCMAKE_BUILD_TYPE=Release
        )
        
        # Windows: use bundled SDL2
        if [[ "$PLATFORM" == "windows" ]]; then
            cmake_args+=(-DSDL2_ROOT="$TOOLS_DIR/windows/SDL2/x86_64-w64-mingw32")
        fi
        # Linux: SDL2 is found via find_package() in CMakeLists.txt
        
        cmake "${cmake_args[@]}"
    fi
    
    cmake --build "$build_dir"
}

cmd_native_run() {
    local codebase="$1"
    local codebase_path
    codebase_path="$(resolve_codebase "$codebase")"
    local bin_dir="$ROOT/bin/$codebase/native"
    local exe
    
    # Extract bridge port from C++ source and start bridge
    local main_native="$codebase_path/sdl/main-native.cpp"
    if [[ -f "$main_native" ]]; then
        local bridge_port
        bridge_port="$(get_udp_port "$main_native")"
        if [[ -n "$bridge_port" ]]; then
            start_bridge "udp" "$bridge_port" || return 1
        fi
    fi
    
    cmd_native_build "$codebase"
    
    # Find executable (Windows .exe or Unix binary)
    if [[ "$PLATFORM" == "windows" ]]; then
        exe="$(find "$bin_dir" -maxdepth 1 -name '*.exe' -type f 2>/dev/null | head -1)"
    else
        exe="$bin_dir/midi_studio_$codebase"
    fi
    
    [[ -x "$exe" ]] || [[ -f "$exe" ]] || log_die "Executable not found in $bin_dir"
    
    log_info "Running $codebase"
    "$exe"
}

# ==============================================================================
# Build Commands - Web (WASM)
# ==============================================================================

cmd_wasm_build() {
    local codebase="$1"
    local codebase_path build_dir app_path
    codebase_path="$(resolve_codebase "$codebase")"
    build_dir="$ROOT/.build/$codebase/wasm"
    app_path="$codebase_path/sdl"
    
    emscripten_init
    
    log_info "Building $codebase (wasm)"
    
    if [[ ! -f "$build_dir/build.ninja" ]]; then
        mkdir -p "$build_dir"
        cd "$build_dir"
        emtool emcmake cmake -G Ninja "$ROOT/core/sdl" \
            -DAPP_PATH="$app_path" \
            -DBIN_OUTPUT_DIR="$ROOT/bin" \
            -DCMAKE_BUILD_TYPE=Release
    fi
    
    cmake --build "$build_dir"
}

cmd_wasm_serve() {
    local codebase="$1"
    local watch="${2:-true}"
    local codebase_path
    codebase_path="$(resolve_codebase "$codebase")"
    local bin_dir="$ROOT/bin/$codebase/wasm"
    local http_port=8080
    
    # Extract bridge port from C++ source and start bridge
    local main_wasm="$codebase_path/sdl/main-wasm.cpp"
    if [[ -f "$main_wasm" ]]; then
        local bridge_port
        bridge_port="$(get_ws_port "$main_wasm")"
        if [[ -n "$bridge_port" ]]; then
            start_bridge "ws" "$bridge_port" || return 1
        fi
    fi
    
    cmd_wasm_build "$codebase"
    
    local html html_name
    html="$(find "$bin_dir" -maxdepth 1 -name '*.html' -type f 2>/dev/null | head -1)"
    html_name="$(basename "$html")"
    
    log_info "Serving at ${BOLD}http://localhost:$http_port/$html_name${RESET}"
    
    if [[ "$watch" == "true" ]]; then
        log_info "Watching for changes... ${DIM}(Ctrl+C to stop)${RESET}"
    fi
    
    python -m http.server "$http_port" -d "$bin_dir"
}

# ==============================================================================
# Utility Commands
# ==============================================================================

cmd_setup() {
    log_info "Setting up development environment..."
    
    # Check base dependencies
    command -v git &>/dev/null || log_die "git is required"
    command -v python &>/dev/null || command -v python3 &>/dev/null || log_die "python3 is required"
    
    # -------------------------------------------------------------------------
    # Emscripten SDK (for WASM builds)
    # -------------------------------------------------------------------------
    if [[ ! -d "$EMSDK_DIR" ]]; then
        log_info "Cloning Emscripten SDK..."
        mkdir -p "$(dirname "$EMSDK_DIR")"
        git clone https://github.com/emscripten-core/emsdk.git "$EMSDK_DIR"
    fi
    
    log_info "Updating emsdk..."
    git -C "$EMSDK_DIR" pull 2>/dev/null || true
    
    log_info "Installing latest Emscripten..."
    "$EMSDK_DIR/emsdk" install latest
    "$EMSDK_DIR/emsdk" activate latest
    
    log_ok "Emscripten ready"
    
    # -------------------------------------------------------------------------
    # Bridge (Rust - for web/native communication)
    # -------------------------------------------------------------------------
    local bridge_dir="$WORKSPACE/open-control/bridge"
    
    if [[ -d "$bridge_dir" ]]; then
        if ! command -v cargo &>/dev/null; then
            log_error "Rust/Cargo not found. Install from https://rustup.rs"
            echo ""
            echo "  curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh"
            echo ""
        else
            log_info "Building bridge..."
            cargo build --release --manifest-path "$bridge_dir/Cargo.toml"
            log_ok "Bridge ready"
        fi
    fi
    
    # -------------------------------------------------------------------------
    # Summary
    # -------------------------------------------------------------------------
    echo ""
    log_ok "Setup complete!"
    echo ""
    echo "Available commands:"
    echo "  ms run <codebase>    Build + run native desktop"
    echo "  ms web <codebase>    Build + serve wasm"
    echo ""
}

cmd_icons() {
    local codebase="${1:-}"
    [[ -z "$codebase" ]] && log_die "Usage: ms icons <codebase>"
    
    log_info "Generating icons for $codebase"
    python "$ROOT/script/icon/builder.py" "$codebase"
}

cmd_clean() {
    local codebase="${1:-}"
    
    if [[ -z "$codebase" ]]; then
        log_info "Cleaning all builds..."
        rm -rf "$ROOT/.build" "$ROOT/bin"
        rm -rf "$ROOT/core/.pio/build"
        rm -rf "$ROOT"/plugin-*/.pio/build
    else
        log_info "Cleaning $codebase..."
        rm -rf "$ROOT/.build/$codebase" "$ROOT/bin/$codebase"
        rm -rf "$(resolve_codebase "$codebase")/.pio/build"
    fi
    
    log_ok "Clean complete"
}

cmd_list() {
    echo "Available codebases:"
    list_codebases | while read -r cb; do
        echo "  $cb"
    done
}

cmd_help() {
    cat <<EOF
${BOLD}MIDI Studio CLI${RESET}

${BOLD}Usage:${RESET} ms <command> [codebase] [options]

${BOLD}Quick commands:${RESET}
  ms core                Build + upload core (teensy)
  ms bitwig              Build + upload bitwig (teensy)
  ms run <codebase>      Build + run native desktop
  ms web <codebase>      Build + serve wasm
  ms monitor <codebase>  Build + upload + serial monitor

${BOLD}Build commands:${RESET}
  ms build <codebase>              Teensy build only
  ms build <codebase> native       Native desktop build
  ms build <codebase> wasm         WebAssembly build

${BOLD}Options:${RESET}
  --release              Use release environment (teensy)
  --no-watch             Disable watch mode (web)

${BOLD}Utilities:${RESET}
  ms setup               Install Emscripten SDK
  ms icons <codebase>    Generate icons
  ms clean [codebase]    Clean builds
  ms list                List codebases

${BOLD}Codebases:${RESET}
$(list_codebases | sed 's/^/  /')
EOF
}

# ==============================================================================
# Main Entry Point
# ==============================================================================

main() {
    local cmd="${1:-help}"
    local arg="${2:-}"
    local arg2="${3:-}"
    
    # Parse global flags
    local env="dev"
    local watch="true"
    for a in "$@"; do
        case "$a" in
            --release)  env="release" ;;
            --no-watch) watch="false" ;;
        esac
    done
    
    case "$cmd" in
        # Quick commands
        core|bitwig)
            cmd_teensy_upload "$cmd" "$env"
            ;;
        run)
            [[ -z "$arg" ]] && log_die "Usage: ms run <codebase>"
            cmd_native_run "$arg"
            ;;
        web)
            [[ -z "$arg" ]] && log_die "Usage: ms web <codebase>"
            cmd_wasm_serve "$arg" "$watch"
            ;;
        monitor)
            [[ -z "$arg" ]] && log_die "Usage: ms monitor <codebase>"
            cmd_teensy_monitor "$arg" "$env"
            ;;
        
        # Explicit build commands
        build)
            [[ -z "$arg" ]] && log_die "Usage: ms build <codebase> [native|wasm]"
            case "$arg2" in
                native) cmd_native_build "$arg" ;;
                wasm)   cmd_wasm_build "$arg" ;;
                "")     cmd_teensy_build "$arg" "$env" ;;
                *)      log_die "Unknown build target: $arg2" ;;
            esac
            ;;
        upload)
            [[ -z "$arg" ]] && log_die "Usage: ms upload <codebase>"
            cmd_teensy_upload "$arg" "$env"
            ;;
        serve)
            [[ -z "$arg" ]] && log_die "Usage: ms serve <codebase>"
            cmd_wasm_serve "$arg" "false"
            ;;
        
        # Utilities
        setup)  cmd_setup ;;
        icons)  cmd_icons "$arg" ;;
        clean)  cmd_clean "$arg" ;;
        list)   cmd_list ;;
        help|--help|-h)
            cmd_help
            ;;
        
        *)
            log_die "Unknown command: $cmd (try: ms help)"
            ;;
    esac
}

main "$@"
