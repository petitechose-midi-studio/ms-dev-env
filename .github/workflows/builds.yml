name: Full Builds

on:
  workflow_dispatch:
    inputs:
      publish:
        description: "Publish nightly release + update Pages"
        type: boolean
        default: false
  schedule:
    - cron: "0 3 * * *"

concurrency:
  group: full-builds-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: write
  pages: write
  id-token: write

jobs:
  guard:
    name: nightly guard
    runs-on: ubuntu-latest
    outputs:
      should_build: ${{ steps.guard.outputs.should_build }}
      source_hash: ${{ steps.guard.outputs.source_hash }}
      nightly_tag: ${{ steps.guard.outputs.nightly_tag }}
      publish: ${{ steps.guard.outputs.publish }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Compute source hash and decide build
        id: guard
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          python - <<'PY'
          import hashlib
          import json
          import os
          import subprocess
          import sys
          import tomllib
          import urllib.request
          from datetime import datetime, timezone

          repo = os.environ.get("GITHUB_REPOSITORY", "")
          token = os.environ.get("GITHUB_TOKEN", "")
          event = os.environ.get("GITHUB_EVENT_NAME", "")
          input_publish = os.environ.get("INPUT_PUBLISH", "false").lower() == "true"

          ws_root = os.getcwd()

          def git(*args: str) -> str:
              out = subprocess.check_output(["git", *args], cwd=ws_root)
              return out.decode("utf-8", errors="replace").strip()

          def git_ls_remote(url: str, branch: str) -> str:
              out = subprocess.check_output(["git", "ls-remote", url, f"refs/heads/{branch}"])
              line = out.decode("utf-8", errors="replace").strip().splitlines()[0]
              return line.split()[0]

          repos_toml = os.path.join(ws_root, "ms", "data", "repos.toml")
          with open(repos_toml, "rb") as f:
              data = tomllib.load(f)
          repos = data.get("repos", [])
          if not isinstance(repos, list):
              print("error: repos.toml: expected [[repos]] array", file=sys.stderr)
              sys.exit(1)

          ms_sha = git("rev-parse", "HEAD")

          lines = [f"ms-dev-env@{ms_sha}"]
          for r in repos:
              url = r.get("url")
              branch = r.get("branch")
              org = r.get("org")
              name = r.get("name")
              if not (url and branch and org and name):
                  continue
              head = git_ls_remote(url, branch)
              lines.append(f"{org}/{name}@{head}")

          h = hashlib.sha256()
          h.update("\n".join(lines).encode("utf-8"))
          source_hash = h.hexdigest()

          # Resolve latest nightly manifest source_hash (best-effort)
          prev_hash = None
          if repo and token:
              req = urllib.request.Request(
                  f"https://api.github.com/repos/{repo}/releases?per_page=50",
                  headers={
                      "Authorization": f"Bearer {token}",
                      "Accept": "application/vnd.github+json",
                      "User-Agent": "ms-dev-env-nightly-guard",
                  },
              )
              with urllib.request.urlopen(req) as resp:
                  releases = json.loads(resp.read().decode("utf-8"))
              nightlies = [
                  r
                  for r in releases
                  if r.get("prerelease") is True and str(r.get("tag_name", "")).startswith("nightly-")
              ]
              nightlies.sort(key=lambda r: r.get("published_at") or "", reverse=True)
              if nightlies:
                  r0 = nightlies[0]
                  assets = r0.get("assets") or []
                  man = next((a for a in assets if a.get("name") == "manifest.json"), None)
                  if man and man.get("browser_download_url"):
                      url = man["browser_download_url"]
                      req2 = urllib.request.Request(
                          url,
                          headers={
                              "Authorization": f"Bearer {token}",
                              "Accept": "application/octet-stream",
                              "User-Agent": "ms-dev-env-nightly-guard",
                          },
                      )
                      with urllib.request.urlopen(req2) as resp:
                          m = json.loads(resp.read().decode("utf-8"))
                      prev_hash = m.get("source_hash")

          # Nightly tag is stable per day (UTC). Reruns update the same release.
          nightly_tag = "nightly-" + datetime.now(timezone.utc).strftime("%Y-%m-%d")

          if event != "schedule":
              should_build = True
          else:
              should_build = (prev_hash != source_hash)

          publish = (event == "schedule") or (event == "workflow_dispatch" and input_publish)

          out_path = os.environ.get("GITHUB_OUTPUT")
          if not out_path:
              print("error: missing GITHUB_OUTPUT", file=sys.stderr)
              sys.exit(1)
          with open(out_path, "a", encoding="utf-8") as f:
              f.write(f"should_build={'true' if should_build else 'false'}\n")
              f.write(f"source_hash={source_hash}\n")
              f.write(f"nightly_tag={nightly_tag}\n")
              f.write(f"publish={'true' if publish else 'false'}\n")
          PY

  build:
    name: build (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    needs: guard
    if: needs.guard.outputs.should_build == 'true'
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            build_native: true
            build_wasm: true
          - os: windows-latest
            build_native: true
            build_wasm: false
          - os: macos-latest
            build_native: true
            build_wasm: false
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.13"

      - name: Setup uv
        uses: astral-sh/setup-uv@v7
        with:
          enable-cache: true

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Install Linux system deps
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential pkg-config libsdl2-dev libasound2-dev libudev-dev libusb-1.0-0-dev

      - name: Sync Python deps
        run: uv sync --frozen --extra dev

      - name: Setup workspace (real)
        run: uv run ms setup --skip-prereqs --yes

      - name: Build midi-studio-loader (rust)
        run: cargo build --release
        working-directory: midi-studio/loader

      - name: Build core (teensy)
        run: uv run ms build core --target teensy --env dev

      - name: Build bitwig (teensy)
        run: uv run ms build bitwig --target teensy --env dev

      - name: Build core (native)
        if: ${{ matrix.build_native }}
        run: uv run ms build core --target native

      - name: Build bitwig (native)
        if: ${{ matrix.build_native }}
        run: uv run ms build bitwig --target native

      - name: Build bitwig extension
        if: runner.os == 'Linux'
        run: uv run ms build bitwig --target extension --extensions-dir _bitwig_extensions

      - name: Build core (wasm)
        if: ${{ matrix.build_wasm }}
        run: uv run ms build core --target wasm

      - name: Build bitwig (wasm)
        if: ${{ matrix.build_wasm }}
        run: uv run ms build bitwig --target wasm

      - name: Verify WASM outputs
        if: ${{ matrix.build_wasm }}
        run: |
          ls -la bin/core || true
          ls -la bin/core/wasm || true
          ls -la bin/bitwig || true
          ls -la bin/bitwig/wasm || true
          test -f bin/core/wasm/midi_studio_core.html
          test -f bin/bitwig/wasm/midi_studio_bitwig.html

      - name: Package dist assets
        if: runner.os == 'Linux'
        run: uv run ms dist package --out dist --require-uploader --wasm --extension --firmware

      - name: Package dist assets
        if: runner.os != 'Linux'
        run: uv run ms dist package --out dist --require-uploader

      - name: Upload dist artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist-${{ runner.os }}
          path: |
            dist

      - name: Upload repos lock (for manifest)
        if: runner.os == 'Linux'
        uses: actions/upload-artifact@v4
        with:
          name: repos-lock
          path: |
            .ms/repos.lock.json

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: bin-${{ runner.os }}
          path: |
            bin

  build_fedora:
    name: build (fedora)
    runs-on: ubuntu-latest
    needs: guard
    if: needs.guard.outputs.should_build == 'true'
    container:
      image: fedora:41
    steps:
      - name: Install system dependencies
        run: |
          dnf install -y \
            curl \
            gcc \
            gcc-c++ \
            git \
            pkgconf-pkg-config \
            python3 \
            SDL2-devel \
            alsa-lib-devel \
            systemd-devel

      - name: Checkout
        uses: actions/checkout@v4

      - name: Install uv
        run: |
          curl -LsSf https://astral.sh/uv/install.sh | sh
          echo "$HOME/.local/bin" >> "$GITHUB_PATH"

      - name: Sync Python deps
        run: uv sync --frozen --extra dev

      - name: Setup workspace (real)
        run: uv run ms setup --skip-prereqs --yes

      - name: Build core (native)
        run: uv run ms build core --target native

      - name: Build bitwig (native)
        run: uv run ms build bitwig --target native

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: bin-fedora
          path: |
            bin

  pages:
    name: deploy demos (pages)
    runs-on: ubuntu-latest
    needs: [guard, build, build_fedora]
    if: |
      github.ref == 'refs/heads/main' &&
      needs.guard.outputs.should_build == 'true' &&
      needs.guard.outputs.publish == 'true'
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure Pages
        uses: actions/configure-pages@v5

      - name: Download Ubuntu artifacts
        uses: actions/download-artifact@v4
        with:
          name: bin-Linux
          path: _artifacts
          merge-multiple: true

      - name: Prepare site
        run: |
          set -euo pipefail

          rm -rf _site
          mkdir -p _site
          cp -R site/* _site/

          # WASM artifacts from the ubuntu build job.
          # download-artifact layout can vary; prefer a deterministic path.
          BIN_ROOT="_artifacts"
          if [ -d "_artifacts/bin" ]; then
            BIN_ROOT="_artifacts/bin"
          fi

          if [ ! -d "${BIN_ROOT}/core/wasm" ]; then
            echo "Expected WASM output not found: ${BIN_ROOT}/core/wasm" >&2
            ls -la "${BIN_ROOT}" || true
            ls -la "${BIN_ROOT}/core" || true
            exit 1
          fi

          if [ ! -d "${BIN_ROOT}/bitwig/wasm" ]; then
            echo "Expected WASM output not found: ${BIN_ROOT}/bitwig/wasm" >&2
            ls -la "${BIN_ROOT}/bitwig" || true
            exit 1
          fi

          mkdir -p _site/demo/core/latest
          mkdir -p _site/demo/bitwig/latest
          cp -R "${BIN_ROOT}/core/wasm/"* _site/demo/core/latest/
          cp -R "${BIN_ROOT}/bitwig/wasm/"* _site/demo/bitwig/latest/
          touch _site/.nojekyll

      - name: Upload Pages artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: _site

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4

  nightly_release:
    name: publish nightly (release)
    runs-on: ubuntu-latest
    needs: [guard, build, build_fedora]
    if: |
      github.ref == 'refs/heads/main' &&
      needs.guard.outputs.should_build == 'true' &&
      needs.guard.outputs.publish == 'true'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.13"

      - name: Download dist artifacts
        uses: actions/download-artifact@v4
        with:
          name: dist-Linux
          path: _dist/dist-Linux

      - name: Download dist artifacts (windows)
        uses: actions/download-artifact@v4
        with:
          name: dist-Windows
          path: _dist/dist-Windows

      - name: Download dist artifacts (macos)
        uses: actions/download-artifact@v4
        with:
          name: dist-macOS
          path: _dist/dist-macOS

      - name: Download repos lock
        uses: actions/download-artifact@v4
        with:
          name: repos-lock
          path: _lock

      - name: Prepare manifest inputs
        run: |
          set -euo pipefail
          rm -rf dist
          mkdir -p dist
          python - <<'PY'
          import shutil
          from pathlib import Path

          src_root = Path('_dist')
          dst = Path('dist')
          for p in src_root.rglob('*.zip'):
              shutil.copy2(p, dst / p.name)
          PY
          mkdir -p .ms
          cp _lock/repos.lock.json .ms/repos.lock.json

      - name: Generate manifest.json
        env:
          SOURCE_HASH: ${{ needs.guard.outputs.source_hash }}
          TAG: ${{ needs.guard.outputs.nightly_tag }}
        run: |
          python - <<'PY'
          import os
          from pathlib import Path
          from ms.services.dist import generate_manifest

          tag = os.environ["TAG"]
          source_hash = os.environ["SOURCE_HASH"]
          generate_manifest(
              workspace_root=Path.cwd(),
              dist_dir=Path("dist"),
              channel="nightly",
              tag=tag,
              out_path=Path("dist/manifest.json"),
              source_hash=source_hash,
          )
          PY

      - name: Publish nightly GitHub release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG: ${{ needs.guard.outputs.nightly_tag }}
          SOURCE_HASH: ${{ needs.guard.outputs.source_hash }}
          MS_SHA: ${{ github.sha }}
        run: |
          set -euo pipefail
          TITLE="Nightly ${TAG#nightly-}"
          NOTES="Automated nightly build.\n\nsource_hash: ${SOURCE_HASH}\nms_dev_env_sha: ${MS_SHA}\n"

          if gh release view "$TAG" >/dev/null 2>&1; then
            gh release edit "$TAG" --prerelease --title "$TITLE" --notes "$NOTES"
          else
            gh release create "$TAG" --prerelease --title "$TITLE" --notes "$NOTES"
          fi

          gh release upload "$TAG" dist/*.zip dist/manifest.json --clobber
